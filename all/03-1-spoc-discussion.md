# lec5 SPOC思考题


NOTICE
- 有"w3l1"标记的题是助教要提交到学堂在线上的。
- 有"w3l1"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。


## 个人思考题
---

请简要分析最优匹配，最差匹配，最先匹配，buddy systemm分配算法的优势和劣势，并尝试提出一种更有效的连续内存分配算法 (w3l1)
# 1.最先匹配：
优点：（1）实现起来比较简单
            （2）由于是按地址从低地址到高地址找可用的空间分区，所以低地址的分区会优先被分配，则高地址有大块的空              闲分区
缺点：（1）容易产生外部碎片
            （2）分配大块时较慢。因为是从低地址开始找，低地址的块都被分配出去，产生各种大小的碎片。要分配大块时则需要一直向高地址遍历，比较费时。
 
# 2.  最优匹配
优点 ： 大部分分配的尺寸较小时，效果很好
        （1） 可以避免大的空闲分区被拆分。由于是从小到大找能用的最小空闲分区，则大块不易被拆分。
         （2）可以减少外部碎片的大小。找的是可用的最小的，因此分出区后，原块余下的碎片也最小
         （3） 实现上来说相对简单
缺点 （1） 依然会有外部碎片
         （2）释放分区较慢。因为排序是按大小排，但释放分区时需要合并地址上相邻的空间块，则需要额外的按地址的搜索，速度较慢。  
         （3） 容易产生大量的无用小碎片
         
# 3.最差匹配
优点：（1）中等大小分配较多时，效果最好
            （2） 可以避免出现太多的无用小碎片
            （3） 分配速度最快。由于是分配满足条件的最大的，空间分区按大小从大到小排，则只需判断第一项即可。
 缺点：（1） 释放分区较慢。同最优匹配一样，按大小排，按地址合并，需要额外的搜索。
             （2） 有外部碎片
             （3） 容易破坏大的空间分区，使得后续难以分配大的分区
             
# 4.伙伴系统
优点： （1） 分配速度较快。从算法上看，可以看做是二分查找，log（n）级别的复杂度，相对较快。
             （2） 无外部碎片。从算法中可以看出，每次都是把2的整数次幂的空间分区直接分出去，因此无外部碎片
缺点： （1）实现相对复杂
             （2）容易产生很多的内部碎片。很少有进程需要的内存大小正好是2的整数次幂，因此大部分分出去的分区都会产生内部碎片。      
             
# 更有效的连续内存分配算法
可以有一些改进的思路，如伙伴算法，不必每次释放内存时都合并，做相应的表计，等实际使用时在合并
对最优匹配发，因为产生的都是很小的外部碎片，每次查找时，可以不必从头开始找，而是从上一次找到的空闲分区开始找。这样做可以提高效率。
            


  + 采分点：说明四种算法的优点和缺点
  - 答案没有涉及如下3点；（0分）
  - 正确描述了二种分配算法的优势和劣势（1分）
  - 正确描述了四种分配算法的优势和劣势（2分）
  - 除上述两点外，进一步描述了一种更有效的分配算法（3分）
 ```
- [x]  

>  

## 小组思考题

请参考ucore lab2代码，采用`struct pmm_manager` 根据你的`学号 mod 4`的结果值，选择四种（0:最优匹配，1:最差匹配，2:最先匹配，3:buddy systemm）分配算法中的一种，在应用程序层面来实现，并给出测试用例。 (spoc)

--- 

## 扩展思考题

阅读[slab分配算法](http://en.wikipedia.org/wiki/Slab_allocation)，尝试在应用程序中实现slab分配算法，给出设计方案和测试用例。


